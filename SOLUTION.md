# Решение тестового задания

## Основное решение: Денормализация

Учитывая следующие ограничения:

1. **Высокая нагрузка на чтение (Read Heavy)**: Операций чтения значительно больше, чем обновлений.
2. **Редкие записи (Write Rare)**: Обновления происходят редко.
3. **Узкое место — БД**: База данных является ограничивающим фактором производительности.

Я выбрал **денормализованную** структуру данных.
Вместо того чтобы хранить ссылки (`cityUuid`) и искать документ Города (City) при каждом чтении Сотрудника (Employee) — что потребовало бы огромного количества JOIN-ов или привело бы к проблеме N+1 запросов — мы храним актуальные названия (`cityName`, `divisionName`, `positionName`) непосредственно в документе `Employee`.

### Структура данных

Документ `Employee` в базе данных будет выглядеть следующим образом:

```typescript
interface IEmployeeDbModel {
  uuid: string;
  firstName: string;
  lastName: string;
  cityName: string; // Денормализованное поле
  divisionName: string; // Денормализованное поле
  positionName: string; // Денормализованное поле
  // ID сохранены для ссылок и потенциальных проверок целостности
  cityUuid: string;
  divisionUuid: string;
  positionUuid: string;
}
```

### Обоснование

- **Производительность чтения**: Методы `employeeWithCityList` и `employeeWithPositionList` могут быть выполнены с помощью **одного запроса** к коллекции `employees`. Никаких объединений (joins), никаких дополнительных поисков. Это минимизирует нагрузку на БД и задержки (latency).
- **Компромисс (обновления)**: Обновление названия города (например, "Astana" -> "Nur-Sultan") становится дорогостоящей операцией. Нам придется найти ВСЕХ сотрудников с этим городом и обновить их документы. Однако, так как по условию "обновления редки", это приемлемая цена за скорость чтения.

## Критически важный компонент производительности: Индексы

**Внимание**: Даже при денормализации производительность пострадает без использования индексов.
Чтобы решение действительно устранило "узкое место в БД", мы **ОБЯЗАНЫ** создать индексы для полей, используемых при фильтрации и сортировке.

Если мы фильтруем по `city` или нам нужно обновить запись по `uuid`, нам необходимы:

- `createIndex({ type: 1 })` — для быстрого поиска всех сотрудников (если `type` используется как дискриминатор).
- `createIndex({ uuid: 1 })` — для быстрого обновления конкретного сотрудника по ID.
- `createIndex({ cityUuid: 1 })` — для быстрого поиска сотрудников при изменении названия Города (чтобы выполнить массовое обновление).

Без индексов БД будет выполнять **Full Table Scan** (полное сканирование коллекции), что сведет на нет все преимущества архитектуры.

## Если контекст изменится

**Редкие чтения, Частая/Интенсивная запись**

Если нагрузка сместится в сторону **Частой записи**:

1. **Денормализация станет вредной**: Преобразование часто обновляемого поля в денормализованную строку означает, что каждая запись в справочнике вызывает тысячи вторичных записей в документах сотрудников. Это "убьет" производительность БД.
2. **Нормализация станет оптимальной**: Мы вернемся к хранению ТОЛЬКО `cityUuid` в документе `Employee`.

- **Обновление (Update)**: Меняем название в документе `City` один раз. Готово. Быстро.
- **Чтение (Read)**: Теперь требует JOIN ($lookup) или 2 запроса (Получить сотрудников -> Получить города -> Смаппить данные). Так как чтения теперь "редкие", дополнительная задержка является допустимой.

## Итог

Для текущей задачи стратегия **Денормализация + Индексы** является оптимальной для максимизации пропускной способности чтения (Read Throughput) ценой усложнения логики обновлений (Update Complexity).

## Контакты

- Telegram: @SayanSotsial
- WhatsApp: +7 747 580 24 84
- github: [Sotsial](https://github.com/Sotsial/)

### Файл Solution.md был написан с использованием LLM
